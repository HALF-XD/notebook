## 排序算法的一些概念

1. 稳定性：

   假定待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序这些记录的相对次序保持不变，称这种排序算法是稳定的，否则称为不稳定的。(如果排序前的第一个 8 和第二个 8 在排序后，还是保持这个顺序，就说明排序是稳定)

2. 对比排序、非对比排序

   Comparison Sort：应用场景更宽泛；但时间较慢；最好的 O(NlogN)；各个语言自带的排序，都是对比排序
   Non-comparison Sort：数据结构的限制；但一般速度更快；最好的 O(N)、O(N+k)

3. 排序方式
   In-Palce：不需要额外的空间
   Out-Of-Place：需要额外的空间存储数据

| 排序算法 | 平均时间复杂度 | 最好       | 最坏       | 空间复杂度 | 排序方式  | 稳定性 | 对比   |
| -------- | -------------- | ---------- | ---------- | ---------- | --------- | ------ | ------ |
| 冒泡排序 | O(n²)          | O(n)       | O(n²)      | O(1)       | In-place  | 稳定   | 对比   |
| 选择排序 | O(n²)          | O(n²)      | O(n²)      | O(1)       | In-place  | 不稳定 | 对比   |
| 插入排序 | O(n²)          | O(n)       | O(n²)      | O(1)       | In-place  | 稳定   | 对比   |
| 希尔排序 | O(n log n)     | O(n log²n) | O(n log²n) | O(1)       | In-place  | 不稳定 | 对比   |
| 归并排序 | O(n log n)     | O(n log n) | O(n log n) | O(N)       | Out-place | 稳定   | 对比   |
| 快速排序 | O(n log n)     | O(n log n) | O(n²)      | O(log n)   | In-place  | 不稳定 | 对比   |
| 堆排序   | O(n log n)     | O(n log n) | O(n log n) | O(1)       | In-place  | 不稳定 | 对比   |
| 计数排序 | O(n + k)       | O(n + k)   | O(n + k)   | O(k)       | Out-place | 稳定   | 非对比 |
| 桶排序   | O(n + k)       | O(n + k)   | O(n²)      | O(n + k)   | Out-place | 稳定   | 非对比 |

## 几个常用排序(基础)

### 冒泡排序 Bubble

![图片展示](https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif)

1. 思路: 一次比较两个元素，如果它们的顺序错误就把它们交换过来。

   (1) 比较相邻的元素。如果 "前一个" 比 "后一个" 大，就交换他们两个。
   (2) 移动指针，继续比较后面的相邻元素。这步做完后，最后的元素会是最大的数。
   (3) 针对所有的元素重复以上的步骤，除了最后一个。
   (4) 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

2. 变量
   (1) 指针
   (2) 水平面
   (3) didSwap 旗帜可以来确定有没有换位置, 当一轮循环后 didSwap 为 false, 则不用再

### 选择排序 Selection

![图片展示](https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif)

1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
3. 重复第二步，直到所有元素均排序完毕。

### 插入排序 Insertion

![图片展示](https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif)

像扑克牌

1. 将待排序序列的第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

### 未整理的排序方式

- 快速排序 Quick Sort：时间复杂度证明
- 希尔排序 Shell Sort
- 归并排序 Merge Sort：建立在归并操作上的一种排序算法。该算法采用分治法（Divide And）
- 基数排序 Radix Sort
- 堆排序 Heap Sort
- 计数排序 Counting Sort
- 桶排序 Bucket Sort

## 一些 case

1. **case1** :
   已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离不超过 k，并且 k 相对于数组长度来说很小。请问选择什么方法对其排序比价好。

2. **case2**:
   判断数组中是否有重复值。必须保证额外空间复杂度为 O(1)。
   如果没有空间复杂度的限制呢？

3. **case3**:
   把两个有序数组合并为一个数组，第一个数组空间正好容纳两个数组的元素。

4. **case4**:
   荷兰国旗问题。只包含 0，1，2 的整数数组进行排序，要求使用交换、原地排序，而不是利用技术进行排序。

5. **case5**:
   在下面的行列都排好序的矩阵中找数,要找的数为 3。

   ```
   0 1 2 5
   2 3 4 7
   4 4 4 8
   5 7 7 9
   ```

6. **case6**:
   给定一个数组，返回需要排序的最短子数组长度
   如：数组 `[1,5,4,3,2,6,7]` ，应该返回 4，因为只有 `[5,4,3,2]` 需要排序。
   最优解时间复杂度 `O(N)`，额外空间复杂度 `O(1)`。

7. **case7**:
   给定一个整形数组 arr，返回如果排序之后，相邻两数的最大差值。
   ​ 如：某数组排序之后为 `[1,2,3,4,7,8,9]`，最大差值来自于 4 和 7，所以返回 3。
   最优解时间复杂度 `O(N)`，额外空间复杂度 `O(N)`。思想来自于桶排序。

## 相关文章网站

- [JavaScript 排序算法汇总](https://www.qcyoung.com/2016/12/18/JavaScript%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/)
- [十大经典排序算法 - runoob.com](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html)
- [算法可视化 - visualgo.net](https://visualgo.net/zh/sorting)
