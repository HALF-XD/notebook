#### 读

- [快速排序（Quicksort）的 Javascript 实现](http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html)
- [JavaScript 排序算法汇总](https://www.qcyoung.com/2016/12/18/JavaScript%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/)
- 【https://www.runoob.com/w3cnote/shell-sort.html】
- 各种排序：【https://www.runoob.com/w3cnote/ten-sorting-algorithm.html】
- 算法可视化：【https://visualgo.net/zh/sorting?slide=1】
- 视频-排序可视化：【https://www.bilibili.com/video/BV1Ex411s7cQ/?spm_id_from=333.788.recommend_more_video.-1】

#### case

<!-- tabs:start -->

##### **case1**

已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离不超过 k，并且 k 相对于数组长度来说很小。请问选择什么方法对其排序比价好。

##### **case2**

判断数组中是否有重复值。必须保证额外空间复杂度为 O(1)。
如果没有空间复杂度的限制呢？

##### **case3**

把两个有序数组合并为一个数组，第一个数组空间正好容纳两个数组的元素。

##### **case4**

荷兰国旗问题。只包含 0，1，2 的整数数组进行排序，要求使用交换、原地排序，而不是利用技术进行排序。

##### **case5**

在行列都排好序的矩阵中找数
0 1 2 5
2 3 4 7
4 4 4 8
5 7 7 9
要找的数为 3

##### **case6**

给定一个数组，返回需要排序的最短子数组长度
如数组 [1,5,4,3,2,6,7]，应该返回 4，因为只有 [5,4,3,2]需要排序。

- 最优解时间复杂度 O(N)，额外空间复杂度 O(1)。

##### **case7**

​ 给定一个整形数组 arr，返回如果排序之后，相邻两数的最大差值。
​ 如：某数组排序之后为 [1,2,3,4,7,8,9]，最大差值来自于 4 和 7，所以返回 3。

- 最优解时间复杂度 O(N)，额外空间复杂度 O(N)。思想来自于桶排序。

##### **建议**

补充说明一：排序算法无绝对优劣

通常不能随便说哪种排序算法号。这个要和排序的元素相关。例如对人的年龄排序或者身高排序，因为这种数据范围通常比较小，可以考虑采用计数排序。但是对于均匀分布的整数，计数排序就不合适了。除非面试题特别说明，否则认为要排序的数据范围是均匀分布的。

补充说明二：为什么叫快速排序

快速排序之所以叫做快速排序，并不代表它比堆排序和归并排序优良。在最好情况下，它的渐进复杂度与堆排序和归并排序是相同的。只是快速排序的常量系数比较小而已。

补充说明二：工程上的排序

1. 工程上的排序是综合排序。
2. 数组较小时，插入排序。
3. 数组较大时，快速排序或其他 O(N\*LogN)的排序。

<!-- tabs:end -->

#### 排序算法

<!-- tabs:start -->

##### **常见排序算法**

- quick sort 快速排序：时间复杂度证明？
- shell sort 希尔排序
- merge sort 归并排序：建立在归并操作上的一种排序算法。该算法采用分治法（Divide And）
- heap sort 堆排序
- selection sort 选择排序
- insertion sort 插入排序
- bubble sort 冒泡排序
- comb sort 梳排序；组合排序
- cocktail sort 鸡尾排序

* 计数排序
* 基数排序
* 桶排序

##### **排序算法分类**

- 比较类排序

  - 交换排序(冒泡排序、快速排序)
  - 插入排序(简单插入排序、希尔排序)
  - 选择排序(简单选择排序、堆排序)
  - 归并排序

- 非比较类排序
  - 基数排序、桶排序、基数排序

##### **在线教程和文档**

<!-- tabs:end -->

#### 排序算法稳定性

排序算法的稳定性：

- 稳定性：假定待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序这些记录的相对次序保持不变，称这种排序算法是稳定的，否则称为不稳定的。(如果排序前的第一个 8 和第二个 8 在排序后，还是保持这个顺序，就说明排序是稳定)
- 稳定的：冒泡排序、插入排序、归并排序、计数排序、基数排序、桶排序
- 不稳定的：选择排序、快速排序、希尔排序、堆排序

#### 排序算法复杂度

时间复杂度：

- `O(N²)` - 冒泡排序、选择排序、插入排序
- `O(N*LogN)` - 归并排序、快速排序、堆排序、希尔排序
- `O(N)` - 计数排序、基数排序（不是基于比较的排序算法，思想基于桶排序）

空间复杂度：

- `O(1)` - 冒泡排序、选择排序、插入排序、堆排序、希尔排序
- `O(LogN)~O(N)` - 快速排序
- `O(N)` - 归并排序
- `O(M)` - 计数排序、基数排序

| 排序算法 | 平均时间复杂度 | 最好情况   | 最坏情况   | 空间复杂度 | 排序方式  | 稳定性 |
| -------- | -------------- | ---------- | ---------- | ---------- | --------- | ------ |
| 冒泡排序 | O(n²)          | O(n)       | O(n²)      | O(1)       | In-place  | 稳定   |
| 选择排序 | O(n²)          | O(n²)      | O(n²)      | O(1)       | In-place  | 不稳定 |
| 插入排序 | O(n²)          | O(n)       | O(n²)      | O(1)       | In-place  | 稳定   |
| 希尔排序 | O(n logn)      | O(n log²n) | O(n log²n) | O(1)       | In-place  | 不稳定 |
| 归并排序 | O(n logn)      | O(n logn)  | O(n logn)  | O(n)       | Out-place | 稳定   |
| 快速排序 | O(n logn)      | O(n logn)  | O(n²)      | O(logn)    | In-place  | 不稳定 |
| 堆排序   | O(n logn)      | O(n logn)  | O(n logn)  | O(1)       | In-place  | 不稳定 |
| 计数排序 | O(n+k)         | O(n+k)     | O(n+k)     | O(k)       | Out-place | 稳定   |
| 桶排序   | O(n+k)         | O(n+k)     | O(n²)      | O(n + k)   | Out-place | 稳定   |
| 基数排序 | O(nk)          | O(nk)      | O(nk)      | O(n + k)   | Out-place | 稳定   |

#### 选择排序 selection sort：

描述：长度为 N 的列表，遍历 N 次，每次遍历获取最大（小）值，放在新列表中。

复杂度：n+(n-1)+(n-2)+ ··· +1 = (1+n)\*n/2 ===> O(n²)

#### 冒泡排序 Bubble sort ：

描述：

（1）从头开始比较每一对相邻元素，如果第 1 个比第 2 个大，就交换它们的位置 ,(执行完一轮后，最末尾就是那个元素的最大的元素)

（2）忽略（1）里曾经找到的最大元素，重复执行步骤一，直到全部元素有序。

复杂度：n+(n-1)+(n-2)+ ··· +1 = (1+n)\*n/2 ===> O(n²)

#### 插入排序 Insertion sort ：

思想：将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增 1 的有序表。
描述：

#### 快速排序 Quicksort

https://en.wikipedia.org/wiki/Quicksort

![Sorting_quicksort_anim](https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif)
