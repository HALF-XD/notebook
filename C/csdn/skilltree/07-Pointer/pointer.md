## 自我检查

1. 练习：结果是什么？

   ```c
   #include<stdio.h>
   main(){
      int arr[]={30,25,20,15,10,5}, *p=arr;
      p++;
      printf("%d\n",*(p+3));
   }
   ```

2. 有语句：`int a[10];`, 则`_____`是对指针变量 p 的正确定义和初始化。
   A) `int p=*a;`
   B) `int *p=a;`
   B) `int p=&a;`
   B) `int *p=&a;`

## 自我检查答案

2.D 选项：a 是数组名，数组名就是地址，无需再用地址符号。

## 快速内容

- 定义`int *p;`后，`*p`是数值， `p`是地址！

  - `*p` 可以当做变量来用，`*`的作用是取后面地址 p 里面的数值
  - p 是当做地址来使用。可以用在 scanf 函数中：`scanf("%d",p);`

- 指针变量，只能存储变量的地址，不能存储整型赋值。

- 指针的计算

  - `*p++` 是：地址会变化。 【取当前值，然后再移动地址】
  - `(*p)++` 是：数值会变化。【取当前值，然后再使数值增加 1】
  - 例题：`*p++` 和 `(*p)++` 的数值分别为多少？
    ```c
    int *p, a[]={1,3,5,7,9};
    p=a;
    // *p++ : 这个本身的数值为1。由于是地址会增加一，所有指针指向数值3了。
    // (*p)++ : 这个本身的数值为1。由于有个++表示数值会增加，指针不移动，但数值1由于自加了一次变成2。
    ```

- 数组 `arr[5] = {1,2,3,4,5};`

  - 数组名是数组首元素的地址，是一个**常量**。
  - 不能进行赋值或者自增自减。
  - `arr` 是常量 `&arr[0]`
  - `*arr` 只能指向的是 `arr[0]`

- 二维数组

  - 二维数组在我们看起来是分行数的，但是在计算机中实际上是连续的。
  - 二维数组相当于指针的指针，用指针的指针对指针进行操作，基本类似于指针对变量直接操作。
  - 在二维数组 `a[i][j]` 中，`a[i]` 是“行名”，等价于指针
    `a[0]` 等价于 a，都表示指针；
    `a[1]` 等价于 `a+1` ，都表示指针；
    `a[1]+1` 等价于 `*(a+1)+1` ，都表示指针；
    注意防止越界！
  - 二维数组元素地址表示：
    (1) `&a[1][2]` (2) `a[1]+2` (3) `*(a+1)+2` (4) `&a[0][0]+(1*4+2)*4`
  - 二维数组元素值表示：
    (1) `a[1][2]` (2) `*(a[1]+2)` (3) `*(*(a+1)+2)` (4) `*(&a[0][0]+(1*4+2)*4)`

- 指针函数和函数指针的区别
  - `int *fun(int,int)` 这是一个函数，`fun` 先和 `(int,int)` 结合成函数，返回值是 `int *` 类型
  - `int (*fun)(int,int)` 是函数指针, `fun` 指针可以指向一个参数列表为 `(int,int)` 返回值为 `int` 的函数

## 指针的笔记

### 1. 指针及指针变量

同 C 语言中其他变量一样，把指针也看成是一种变量即可，这种变量专门存储地址值。

```c
int a = 100;
char b = 'o';
double c = 100.5;

int* iptr;
char* cptr;
double* dptr;

iptr = &a;
cptr = &b;
dptr = &c;
```

```c
int a = 100;
int* iptr = &a;
int b = *iptr;
```

### 2. 指针变量的引用

引用指针变量时有以下三种情况：

① 给指针变量赋值。 ② 引用指针变量指向的变量。 ③ 引用指针变量的值。

```c
int a, *p;
p=&a;				//把a的地址赋给指针变量p
printf("%d",*p);	//以整数形式输出指针变量p所指向的变量的值，即a的值
*p=1;				//将整数1赋给p当前所指向的变量，由于p指向变量a，相当于把1赋给a，即a=1
printf("%o",p);		//以八进制形式输出指针变量p的值，由于p指向a，相当于输出a的地址，即&a
```

**注意** :

要熟练掌握两个有关的运算符：

1. `＆` 取地址运算符。`&a` 是变量 `a` 的地址。
2. `*` 指针运算符（或称"间接访问"运算符），`*p` 代表指针变量 `p` 指向的对象。

### 3. 指针变量作为函数参数

- 函数的参数不仅可以是整型、浮点型、字符型等数据，还可以是指针类型。它的作用是将一个变量的地址传送到另一个函数中。
- **例子`case1.c`**: 指针变量作为函数参数。
- 在函数调用时，将实参变量的值传送给形参变量，采取的依然是值传递的方式。
- 不可能通过执行调用函数来改变实参指针变量的值，但是可以改变实参指针变量所指变量的值。
- **例子`case2.c`**: 函数的调用可以(而且只可以)得到得到一个返回值，而使用指针变量做参数，可以得到多个变化了的值。

### 4. 通过指针引用数组

- **例子`case3.c`**: 通过指针引用数组元素 (下标法 / 通过数组名计算数组元素地址，找出元素的值 / 用指针变量指向数组元素)
- **例子`case4.c`**: 执行会出错，看看呢
- **例子`case5.c`**: 用 while 实现输出数组 a 的前 5 个元素

引用一个数组元素，可以用以下两种方法：

1. 下标法，如 `a[i]` 形式；
2. 指针法，如 `*(a+i)` 或 `*(p+i)` 。其中 `a` 是数组名，`p`是指向数组元素的指针变量，其初值为 `p=a`；

### 5. 用数组名作函数参数

数组元素作实参时，参数传递具有单向性，即实参的改变可以影响形参，而形参的改变无法影响实参。

假设已经定义了一个函数，其原型为：

```c
void swap(int x, int y); // 函数定义
swap(int a[1], int a[2]); // 函数调用
```

- 变量名作为函数参数:
  - 传递：变量名,
  - 传递的信息:变量的值,
  - **不能**通过函数调用能否改变实参的值
- 把数组名作为函数参数:
  - **例子`case6.c`**：将数组 a 中 n 个整数按相反顺序存放。
  - 传递：数组名或指针变量,
  - 传递的信息:实参数组首元素的地址,
  - **能**通过函数调用能否改变实参的值
  - 实参和形参的改变可以相互影响
  - 实参数组名代表首元素的地址，而形参是用来接收从实参传递过来的数组首元素的地址的，因此形参是一个指针变量。

**例子`case7.c`**:用指针方法对 10 个整数按由小到大顺序排列。如果让指针变量做形参，必须先使指针变量有确定值，指向一个已定义的对象

### 6. 通过指针引用多维数组

#### 1. 多维数组元素的地址

请记住： `*(a+i)` 和 `a[i]` 是等价的

如果 `a` 是一维数组名，`a[i]` 代表 `a` 数组序号为 `i` 的元素的存储单元。
如果 `a` 是一维数组名，则 `a[i]` 是一维数组名，它只是一个地址，并不代表某一元素的值。

#### 二维数组

**例子`case8.c`**： 输出二维数组的地址和值

一个 3 行 4 列的二维数组，他有 3 行 4 列，定义为：

```c
int a[3][4] = {{1,3,5,7},{9,11,13,15},{17,19,21,23}};
```

二维数组 a 的有关指针

| 表示形式                            | 含义                                           | 地址        |
| ----------------------------------- | ---------------------------------------------- | ----------- |
| `a`                                 | 二维数组名，指向一维数组 `a[0]`，即 0 行首地址 | 2000        |
| `a[0]`, `*(a+0)`, `*a`              | 0 行 0 列元素地址                              | 2000        |
| `a+1`, `&a[1]`                      | 1 行首地址                                     | 2016        |
| `a[1]`,`*(a+1)`                     | 1 行 0 列元素 `a[1][0]`的地址                  | 2016        |
| `a[1]+2`, `*(a+1)+2`, `&a[1][2]`    | 1 行 2 列元素 `a[1][2]`的地址                  | 2024        |
| `*(a[1]+2)`, `((a+1)+2)`, `a[1][2]` | 1 行 2 列元素 `a[1][2]`的值                    | 元素值为 13 |

再次强调： 二维数组名( 如 a )是指向行的。因此`a + 1`中的 `1` 代表一行中全部元素所占的字节数 。
一维数组名 (如`a[0]`,`a[1]`)是指向列元素的。`a[0] + 1` 中的 `1` 代表一个 `a`元素所占的字节数。

在指向行的指针前面加一个`*` ，就转换为指向列的指针。

例如，`a` 和 `a+1` 是指向行的指针，在它们前面加一个 `*` 就是 `*a` 和 `*(a+1)`，它们就成为指向列的指针，分别指向 a 数组 0 行 0 列的元素和 1 行 0 列的元素。

反之，在指向列的指针前面加 `&`,就成为指向行的指针。

例如 `a[0]` 是指向 0 行 0 列元素的指针，在它前面加一个`&`, 得 `&a[0]`，由于 `a[0]` 与 `*(a+0)` 等价，因此 `&a[0]` 与 `&*a` 等价，也就是与 `a` 等价，它指向二维数组的 0 行。

#### 2. 指向多维数组元素的指针变量

1. 指向数组元素的指针变量
   **例子`case9.c`**: 用指向数组元素的指针变量输出二维数组各元素的值
2. 指向由 m 个元素组成的一维数组的指针变量
   **例子`case10.c`**: 输出二维数组任一行任一列元素的值
3. 用指向数组的指针作函数参数
   **例子`case11.c`**: 有一个班，3 个学生，各学 4 门课，计算总平均分数以及第 n 个学生成绩
   **例子`case12.c`**: 查找一门以上课程不及格的学生，输出他们的全部课程的成绩

### 7. 通过指针引用字符串

1. 字符串的引用方式

   字符串是存放在字符数组中的，引用字符串，有以下两种方法：
   (1).通过数组名和下标 **例子`case13.c`**
   (2).通过字符指针变量引用一个字符串常量 **例子`case14.c`**

   例子：将字符串 a 赋值给字符串 b,然后输出字符串 b

   - 方法:字符数组: **例子`case15.c`**
   - 方法:指针变量: **例子`case16.c`**

2. 字符指针作函数参数

   **例子`case17.c`** 函数的形参和实参分别用字符数组名或字符指针变量

3. 字符指针变量作形参和实参

   **例子`case18.c`**

4. 字符指针变量和字符数组变量的比较

### 8. 返回指针值的函数

1. 例子： 有 a 个学生，每个学生有 b 门成绩。要求在用户输入学生的学号后，能输出该学生的全部成绩。用指针函数实现。
   **例子`case19.c`**

2. 例子： 找出其中有不及格学生的成绩及其序号。
   **例子`case20.c`**

### 9. 指针数组和多重指针

1. 指针数组, 例子: 将若干字符串按照字母顺序(由小到大)输出
   **例子`case21.c`** :

2. 指向指针数据的指针(**指针的指针**),例子: 使用指向指针数据的指针变量
   **例子`case22.c`** :
   **例子`case23.c`** : 有一个指针数组，其元素分别指向一个整型数组的元素，用指向指针数据的指针变量，输出整型数组各元素的值

### 10. 动态内存分配与指向它的指针变量

- 1. 内存的动态分配
     全局变量是分配在内存中的静态存储区的，非静态的局部变量(包括形参)是分配在内存中的动态存储区的，这个存储区是一个称为`栈（stack）`的区域。C 语言允许建立动态存储分配区域，存放临时用的数据。这些临时数据存放在一个特别的存储区，称为`堆（heap）`区。由于未在声明的部分定义他们为变量或数组，因此不能通过变量名或数组名去引用这些数据，只能通过指针来引用。

- 2. 建立内存的动态分配

  - 2.1. 用 `malloc` 函数开辟动态存储区
    其函数原型为

    ```c
    void *malloc(unsigned int size);
    ```

    在内存的动态存储区分配一个长度为 `size` 的连续空间，形参 `size` 的类型为无符号整形。

    ```c
    malloc(100);   //  开辟100字节的临时分配域，函数值为其第一个字节的地址
    ```

  - 2.2 用 `calloc` 函数开辟动态存储区
    其函数原型为

    ```c
    void *calloc(unsigned n, unsigned int size);
    ```

    在内存中分配 `n` 个长度为 `size` 的连续空间。

    ```c
    p=calloc(50,4); // 开辟 50x4 个字节的临时分配域，把起始地址赋给指针变量 p
    ```

  - 2.3 用 `realloc` 函数重新分配动态存储区
    其函数原型为

    ```c
    void *realloc(void *p, unsigned int size);
    ```

    如果已经通过 `malloc` 或 `calloc` 函数获得了动态空间，想改变大小，可以用 `recalloc` 函数重新分配。

    ```c
    recalloc(p, 50); // 将 p 所指向的已分配的动态空间改为 50 字节
    ```

  - 2.4 用 `free` 函数释放动态存储区
    其函数原型为

    ```c
    void free(void *p);
    ```

    其作用是释放指针变量 p 所指向的动态空间，使这部分空间能重新被其他变量使用。`p` 应是最后一次调用 `calloc` 或 `malloc` 函数时得到的函数返回值。如：

    ```c
    free(p); // 释放指针变量 p 所指向的已分配的动态空间
    ```

    `free` 函数无返回值。
    `# include<stdlib.h>` 指令把 `stdlib.h` 头文件包含到程序中。

  3.  void 指针类型
      **例子`case24.c`**

### 指针小结

#### 1. 指针的含义

**指针就是地址**，凡是出现"指针"的地方，都可以用"地址"代替，例如，变量的指针就是变量的地址，指针变量就是地址变量。

要区分**指针和指针变量**。

- 指针就是地址本身，例如 2008 是某一变量的地址，2008 就是变量的指针。
- 而指针变量是用来存放地址的变量。指针变量的值是一个地址。

#### 2. 指针的指向

只有与指针变量的基类型相同的数据的地址才能存放在相应的指针变量中。

```c
int a, *p;  // p是 int * 型的指针变量，基类型是 int 型
float b;
p=&a;       // a 是 int 型，合法
p=&b;       // b 是 float 型，类型不匹配
```

`void *` 指针是一种特殊的指针，不指向任何类型的数据，如果需要用此地址指向某类型的数据，应先对地址进行类型转换。显示或隐示的类型转换。

#### 3. 指针变量的归纳比较

| 变量定义      | 类型表示     | 含义                                                |
| ------------- | ------------ | --------------------------------------------------- |
| `int *p[4]`   | `int *[4]`   | 定义指针数组 p，它由 4 个指向整型数据的指针元素组成 |
| `int (*p)[4]` | `int (*)[4]` | p 为指向包含 4 个元素的一维数组的指针变量           |
| `int *p()`    | `int *()`    | p 为返回一个指针的函数，该指针指向整型数据          |
| `int (*p)()`  | `int (*)()`  | p 为指向函数的指针，该函数返回一个整型值            |
| `int **p`     | `int **`     | p 是一个指针变量，它指向一个指向整型数据的指针变量  |
| `void *p`     | `void *`     | p 是一个指针变量，其基类型为 void，不指向具体的对象 |

#### 5. 指针运算

a. 指针变量加减一个整数

例如： p++, p- -, p+i, p-i, p+=i, p-=i 等均是指针变量加(减)一个整数。

将该指针变量的原值和它指向的变量所占用的存储单元的字节数相加(减)

b. 指针变量赋值

将一个变量地址赋给一个指针变量。如：

```c
p=&a;         //  将变量a的地址赋值给p
p=array;      //  将数组array首元素的地址赋给p
p=&array[i];  // 将数组 array 第 i 个元素的地址赋给p
p=max();      // max为已定义的函数，将max的入口地址赋给p
pa=p2;        // p1和p2是基类型相同的指针变量，将p2的值赋给p1
```

c. 两个指针变量可以相减

如果两个指针变量都指向同一个数组中的元素，则两个指针变量值之差是两个指针之间的元素个数。

d. 两个指针变量比较

若两个指针变量指向同一个数组中的元素，则可以进行比较。指向前面的元素的指针变量"小于"指向后面元素的指针变量。如果 p1 和 p2 不指向同一数组则比较无意义。

#### 6. 指针变量可以有空值

指针变量可以不指向任何变量，可以这样表示：`p=NULL;`

其中，NULL 是一个符号常量，代表整数 0。

在 stdio.h 头文件中对 NULL 进行了定义： `# define NULL 0`

它使 p 指向地址为 0 的单元。系统保证使该单元不作他用。

**注意**：

- 不应把一个整数赋给指针变量。
- p 的值为 NULL 与未对 p 赋值是两个不同的概念。
- 任何指针变量或地址都可以与 NULL 作相等或不相等的比较，例如： `if (p==NULL)`。
